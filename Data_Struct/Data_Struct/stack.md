<?xml version="1.0" encoding="utf-8"?>
<RuleSet Name="New Rule Set" Description=" " ToolsVersion="10.0">
</RuleSet>

##	栈
###	顺序栈
*	栈是限制在一端进行插入操作和删除操作的线性表（俗称堆栈）。
*   允许进行操作的一端成为“栈顶”，另一固定端成为“栈底”，当栈中没有元素时成为“空栈”。
*   特点“先进后出”

###	链式栈
  *插入操作和删除操作均在链表头部进行，链表尾部就是栈底，栈顶指针就是头指针。
```
struct node_t{
data_t data;
struct node_t *next;
};
```

### 队列
队列是限制在两端进行插入操作和删除操作的线性表。
允许进行存入操作的一端称为“队尾”，允许进行删除操作的一端称为“队头”。
  *线性结构
  *先进先出（只允许在表尾插入，表头取出）
  *顺序队列 sequeue
  *链式队列 linkqueue

### 二叉树
二叉树是n个节点的有限集合，它或者是空集，或者由一个根节点以及两个互不相交的、
分别称为左子树和右子树的二叉树组成。
二叉树与普通序列树不同，二叉树严格区分左孩子和右孩子。
 
* 二叉树第i层上的节点最多2^i-1个。
* 深度为k的二叉树最多有2^k-1个节点。
* 在任意一个二叉树中，树叶的数目比度数为2的节点数目多1。
* 总结点数为各节点之和。
* 总节点数为所有子节点数加一。

####    满二叉树
深度为K时有2^k-1个节点的二叉树。

####    完全二叉树
只有最下面两层有度数小于2的节点，且最下面一层的叶节点集中在最左边的若干位置上。

### 哈希表
hash表，又称为散列表。设计哈希表主要注意以下两点：
  *如何选取哈希函数
  *如何处理冲突。

综上所述，对哈希表的含义描述如下：
*   根据选取的哈希函数H（key）和处理冲突的方法，将一组记录（R1,R2,R3...）映射到记录的存储空间，所得到的记录表就是哈希表。
*   关于哈希表的关键就是上面的两个问题。
*   选取哈希函数的方法很多，原则上尽可能将记录均匀分布，以减少冲突现象的发生。
    *   直接地址法
    *   数字分析法
    *   平方取中法
    *   叠加法
    *   保留除数法
    *   随机函数法

1、直接地址法：
h(key) = a*key + b
* 其中 a，b为常数。

保留除数法：
* 又称为质数除余法，设hash表空间长度为m，选取一个不大于m的最大质数p。
* 则hash函数： H（key） = key % p
* 选取最大质数的原因就是为了减小冲突发生的频率。

### 排序
* 插入排序
* 交换排序
* 选择排序
* 归并排序
* 基数排序

####    直接插入排序
插入的过程上就是一个key的比较过程，即每插入一个记录时，都将其key与当前记录中的key进行比较，
找到待插入位置后将其插入即可。
* 实例参考 ww_sort.c_


### 静态库的特点
* 编译（链接）时静态库中相关的代码复制到可执行文件中。
* 程序中包含代码，运行时不需要静态库。
* 程序运行时无需加载库，运行速度更快。
* 占用更多磁盘空间和内存空间。
* 静态库升级后，需要重新编译。

####    静态库的创建
* 确定库中函数的功能、接口。
* 编写库源码hello.c（如下）
* 编译生成目标文件
* gcc -c hello.c -Wall(生成.o文件)
* 创建静态库hello
* ar crs libhello.a hello.o
* 查看库中符号信息，（nm libhello.a）

```
void hello(){
    printf("hello world");
}

void hello();
int main(){
    hello();
    return 0;
}
```
####    链接静态库
* 编写应用程序调用库中函数
* 编译test.c并链接静态库libhello.a
* gcc -o test test.c -L -lhello

####    链接共享库
* gcc -c -fPIC hello.c bye.c -Wall
* 确定库中的函数功能及接口
* 编写库源码
* gcc -shared -o libcommom.so.1 hello.o bye.o
* 创建共享库
* 为共享库创建符号链接
* ln -s libcommon.so.1 libcommon.so
* gcc -o test test.c -L. -lcommon
* 当目录下同时存在静态库和共享库时，编译器首先会寻找链接共享库。
* 可以添加-static参数指定链接静态库
* 添加共享库的加载路径：export LD_LIBRARY_PATH=$LD_LIBRART_PATH:.

*让系统能够找到要加载的共享库的三种方法*
* 把库拷贝到/usr/lib和/lib目录下。
* 在LD_LIBRARY_PATH环境变量中添加库所在路径。
* 添加/etc/ld.so.conf.d/*.conf文件，执行ldconfig刷新。